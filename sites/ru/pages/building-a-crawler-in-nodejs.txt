=title Делаем веб-клиент (сканер) с помощью Node.js
=timestamp 2015-04-05T16:49:01
=indexes http, http.get
=status show
=books nodejs, javascript
=author szabgab
=original building-a-crawler-in-nodejs
=translator name2rnd
=archive 1
=comments_disqus_enable 0

=abstract start

Создание веб-сервера, или веб-приложения, как мы делали в <a href="/getting-started-with-nodejs">первом примере</a>, может быть интересным,
также и с созданием веб-сканера. Вы знаете, это такая штука, которая скачивает страницы и делает с ними что-нибудь интересное.

Давайте начнем с чего-нибудь простого.

=abstract end

Класс <a href="http://nodejs.org/api/http.html">http</a>, который мы рассматривали ранее, предоставляет для этого несколько методов.
Мы рассмотрим метод <a href="http://nodejs.org/api/http.html#http_http_get_options_callback">http.get</a>, который предоставляет простой,
хотя и ограниченный интерфейс.

<include file="examples/node/crawl_01.js">

Первая часть кода это просто проверка, передал ли пользователь URL в <a href="/argv-raw-command-line-arguments-in-nodejs">командной строке</a>.

Как только мы получили <hl>url</hl>, мы вызываем <hl>http.get</hl>, передавая url и коллбек (функцию обратного вызова).
Коллбек будет вызван с <a href="http://nodejs.org/api/http.html#http_class_http_serverresponse">объектом ответа</a>.

Давайте посмотрим, как ведет себя наш скрипт с различными параметрами.

Сначала запустим его вообще без параметров:

<code>
$ node crawl_01.js 
Usage: /Users/gabor/work/articles/code-maven/examples/node/crawl_01.js URL
</code>

Ок, он ответил, что нам нужно передать ему URL.

<code>
$ node crawl_01.js http://code-maven.com/
Got response: 200
</code>

Выглядит нормально.

Давайте запросим страницу, которой не существует:

<code>
$ node crawl_01.js http://code-maven.com/x
Got response: 404
</code>

Выглядит правильно, мы получили <a href="http://en.wikipedia.org/wiki/HTTP_404">код http 404</a> как и ожидалось, но:
он завис. Не знаю, сколько я ждал, пока он закончил работу. Может быть, минуту или больше. 
Это не совсем то, чего мы хотим, не так ли?

Сначала я подумал, что у меня какая-то проблема с сервером, поэтому я попробовал другой запрос:

<code>
$ time node crawl_01.js http://google.com/
Got response: 302
</code>

<a href="http://en.wikipedia.org/wiki/HTTP_302">Код http 302</a> выглядит правильно, но после этого скрипт опять завис как и раньше.

В общем, проблема не в моем сервере.
Я не был уверен, как решить эту проблему, поэтому я решил двигаться дальше. В конце концов, мы получили верный код ответа, и все еще хотим получить
содержимое ответа. Так как тут все асинхронное, то содержимое совершенно не обязательно прийдет к нам в момент, когда будет вызван коллбек.
Мы должны использовать <hl>объект ответа</hl> и добавить немного кода, чтобы забрать пришедшие данные.

<h2>Получение данных</h2>

<include file="examples/node/crawl_02.js">

Как только соединение установлено и сервер отдал какой-то ответ, Node.js вызывает коллбек, передавая объект ответа.
Это все можно найти в переменной <hl>res</hl>.

Мы добавили два коллбека в это объект: <hl>res.on('data', function(chunk) { ... </hl> - будет вызываться каждый раз, когда придет очередная
порция данных, отправленных сервером. Если страница маленькая, то может быть он будет вызван всего один раз, но если страница большая,
то может потребоваться некоторое время (даже несколько секунд?), чтобы получить все данные. Тем временем, мы можем сделать что-нибудь другое.
Таким образом, эта функция будет вызываться каждый раз, когда к нам приходят какие-то данные. Параметр, передаваемый в функцию, будет содержать
текущую порцию данных.

Мы создали переменную <hl>content</hl>, к которой будем добавлять текущую порцию данных.

Конечно, мы предполагаем, что размер страницы не превышает объем памяти. Это вполне разумное допущение в случае html страницы.

Второй коллбек, добавленный к событию, сработает тогда, когда мы завершим получение данных:
<hl>res.on('end', function() { ...</hl>

Без этого мы не сможем быть уверены, что получили все данные, которые сервер собирался отправить.
Мы просто выведем в консоль 'end' и выведем размер содержимого (<hl>content</hl>), которое мы получили от сервера.

Давайте запустим теперь наш скрипт:

<code>
$ node crawl_02.js http://code-maven.com/
Got response: 200
end
20558
</code>

Итак, главная страница <a href="/">Code Maven</a> имеет размер 20,558 байт.

<code>
$ node crawl_02.js https://perlmaven.com/
Got response: 200
end
18487
</code>

По-видимому, главная страница <a href="https://perlmaven.com/">Perl Maven</a> меньше.

А что на счет страниц, которые зависли?

<code>
$ node crawl_02.js http://code-maven.com/x
Got response: 404
end
7641
</code>

Они больше не зависают!

<code>
$ node crawl_02.js http://google.com/
Got response: 302
end
261
</code>

И эта тоже не зависает.

По-видимому, ранее скрипт ожидал, что мы будем и дальше забирать данные. И вот почему он ждал, пока не отключился по таймауту.
Хотя мне все равно не понятно, почему он не зависал в случае ответа 200.

<h2>На самом деле порция-за-порцией?</h2>

Тут есть две закомментированных строки. Если мы уберем <hl>//</hl> с первой, где код <hl>console.log('chunk ' + chunk.length);</hl>,
и снова запустим скрипт:

<code>
$ node crawl_02.js http://code-maven.com/
Got response: 200
chunk 1235
chunk 12672
chunk 1408
chunk 1408
chunk 1408
chunk 1408
chunk 1026
end
20558
</code>

мы сможем увидеть, что получаем данные несколькими частями.

<h2>Содержимое в случае кода 302</h2>

Если мы уберем второй комментарий <hl>//</hl>, где код <hl>console.log(content);</hl>, тогда мы увидим содержимое страницы.

К примеру:

<code>
$ node crawl_02.js http://google.com/
Got response: 302
chunk 261
end
261
<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>302 Moved</TITLE></HEAD><BODY>
<H1>302 Moved</H1>
The document has moved
<A HREF="http://www.google.co.il/?gfe_rd=cr&amp;ei=abcdVK1234GG8Qftxx1234">here</A>.
</BODY></HTML>
</code>

Goole.com переадресовывает на локальную версию Google.

<h2>Выводы</h2>

Это хороший старт для сканера, но многое нужно сделать. На самом деле, вот несколько сканеров на Node.js, которые предоставляют
более высокий уровень абстракции.

<h2>Продвинутые сканеры</h2>

Для получения более продвинутого сканера нам нужно взглянуть на один их этих проектов:
<a href="https://github.com/cgiffard/node-simplecrawler">node-simplecrawler</a>,
<a href="https://github.com/sylvinus/node-crawler">node-crawler</a>, and
<a href="https://github.com/mikeal/spider">spider</a>.
