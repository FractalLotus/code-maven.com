=title Python package dependency management - pip freeze
=timestamp 2021-09-18T07:30:01
=indexes python, pip
=status show
=books python
=author szabgab
=archive 1
=comments_disqus_enable 0
=show_related 1

=abstract start

Making sure the dependencies of a large project work well together is not an easy task. In this article I try to describe a process that might work for you as well.

=abstract end

<h2>Getting started</h2>

Create two empty files: requirements.txt and constraints.txt and add both of them to version control.

<h2>Adding new packages</h2>

As we need new python packages add their names to the requirements.txt file without any restriction and run

<code>
pip install -r requirements.txt -c constraints.txt
</code>

Verify that the new package works as needed. (Run your own tests). Then run

<code>
pip freeze > constraints.txt
</code>

Then commit both <b>requirements.txt</b> and <b>constraints.txt</b> to your version control system.

<h2>Fresh installations</h2>

Later, any time you want to install packages to a fresh installation use

<code>
pip install -r requirements.txt -c constraints.txt
</code>

<h2>Require specific version of a package?</h2>

If your application requires a specific version of a package add that information to the requirements.txt file.

<code>
package-name==SPECIFIC_VERSION
</code>

<h2>What if we cannot install?</h2>

Because the required new package and the constraints file require different versions of something?

You can try to adjust the version of the problematic packages listed in the constrains.txt file and see if any of them satisfies all the
requirements and then run your tests and make sure your code still work after changing the constraint and reinstalling all the dependencies.


<h2>Upgrade a package</h2>

If later you need to upgrade one of your immediate dependencies becasuese you need some feature that only in a newer version exist then
add this information as a minimum requirement to the requirements.txt file: <b>package>=SOME_VERSION</b>


<h2>Removing required packages</h2>

We can simply remove the pacakge from the requirements.txt file. The fact that it and its dependencies are listed in the constraints.txt file
does not matter. They won't be installed. The only problem is that now we might have some lines in the constraints.txt file that are not relevant
any more and that might impact a later installation. If you do the regular maintenance as described below then this will be cleaned up the next time
you do it.

<h2>Regular maintenance</h2>

You can get by with the same versions of your dependency for a long time, but eventually you'll reach a point when you need a newer version of
one of your dependencies. For example because it has a new feature that you need or because there is a bug-fix in it.

However every upgrade has the risk of breaking something in your application. So many people try to avoid it. They even us the expression:
"If it isn't broken don't fix it.". However we know that upgrading a package that is several years old to its current version carries a lot more risk
than doing regular upgrades. Checking reqularly if you can upgrade also has the advantage that if there some breaking change you can report it
to the package maintainers soon after it happens. That report might help them revert the change that breaks your code if possible.

Remove some or all of the entries from the constraints.txt file. Reinstall all the packages
<b>pip install --upgrade -r requirements.txt -c constraints.txt</b> would probably also work.
Run your tests. You do have a good set of tests, don't you?

In you Continuous Integrqation (CI) system have a task that would install your dependencies without the constraints.txt file. Just with
<b>pip install -r requirements.txt</b> and then run your tests. If this fails check what is the source of the problem and report it or fix it.

<h2>Compability with old file formats</h2>

This is not strictly related, but I just encountered this problem at a client. A newer version of <a href="https://www.h5py.org/">h5py</a> could
not read a file created by an older version. In our regular tests we did not notice this problem as our regular tests never tried to open the old files.
They only read in from files that were created in the same test-run with the same version of h5py.

So add examples of every file-format created by your code to your test-data and make sure part of your testing is to read in these files.


